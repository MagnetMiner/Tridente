<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SISTEMA TRIDENTE 游댬 | ZONA CENTRAL CHILE</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000508;
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }

        #sonar-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000910; 
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI OVERLAY */
        .hud-panel {
            position: absolute;
            padding: 15px;
            border: 1px solid #005544;
            background: rgba(0, 10, 10, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
            pointer-events: none;
            z-index: 20;
        }

        #top-left { top: 20px; left: 20px; }
        #bottom-right { bottom: 20px; right: 20px; text-align: right; }

        h1 { margin: 0; font-size: 20px; text-shadow: 0 0 5px #00ffcc; }
        h2 { margin: 0; font-size: 12px; color: #008866; margin-bottom: 5px; }
        p { margin: 2px 0; font-size: 11px; }
        .alert { color: #ff3333; font-weight: bold; }
        .coordinates { color: #aaa; font-size: 9px; }

        /* Efecto de pantalla antigua */
        .scanline {
            width: 100%; height: 100px; z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 204, 0.03) 50%, rgba(0,0,0,0) 100%);
            position: absolute; bottom: 100%;
            animation: scanline 8s linear infinite; pointer-events: none;
        }
        @keyframes scanline { 0% { bottom: 100%; } 100% { bottom: -100px; } }
    </style>
</head>
<body>

    <div id="sonar-container">
        <canvas id="tridenteCanvas"></canvas>
        <div class="scanline"></div>

        <div id="top-left" class="hud-panel">
            <h1>RED TRIDENTE 游댬</h1>
            <h2>ZONA: LOS VILOS - SAN ANTONIO</h2>
            <p>BOYAS ACTIVAS: 6/6</p>
            <p>CONFIGURACI칍N: ZIG-ZAG (ASW BARRIER)</p>
            <hr style="border-color: #004433">
            <p>OBJETIVO: <span class="alert" id="target-status">BUSCANDO...</span></p>
        </div>

        <div id="bottom-right" class="hud-panel">
            <h2>KOLMOGOROV + Z-ENGINE</h2>
            <p>VISCOSIDAD ($Z_I$): 0.85</p>
            <p>PREDICCI칍N: <span style="color:#0f0">ACTIVA</span></p>
            <p>LAT REF: -33.500 | LON REF: -71.600</p>
        </div>
    </div>

<script>
    const canvas = document.getElementById('tridenteCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    
    // Variables de Geograf칤a
    let coastPoints = [];
    const buoys = [];

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        generateCoastline();
        initBuoys();
    }
    
    window.addEventListener('resize', resize);
    
    // ==========================================
    // 1. GENERACI칍N DEL MAPA (Costa de Chile)
    // ==========================================
    function generateCoastline() {
        coastPoints = [];
        // La costa de Chile Central va diagonal hacia el SW
        // Aqu칤 simulamos el borde derecho (Tierra)
        let steps = 50;
        for(let i=0; i<=steps; i++) {
            let y = (height / steps) * i;
            // Una curva sinuosa para simular geograf칤a
            let baseX = width * 0.75; // La costa empieza al 75% del ancho
            let irregularity = Math.sin(i * 0.5) * 20 + Math.cos(i * 0.2) * 40;
            // Inclinaci칩n geogr치fica (m치s al oeste hacia el sur)
            let tilt = (i / steps) * -50; 
            
            coastPoints.push({x: baseX + irregularity + tilt, y: y});
        }
    }

    // Funci칩n para obtener X de la costa dada una Y (para colisiones)
    function getCoastX(y) {
        // Interpolaci칩n simple
        let index = Math.floor((y / height) * (coastPoints.length - 1));
        if (index < 0) index = 0;
        if (index >= coastPoints.length) index = coastPoints.length - 1;
        return coastPoints[index].x;
    }

    // ==========================================
    // 2. CONFIGURACI칍N DE BOYAS (ZIGZAG)
    // ==========================================
    function initBuoys() {
        buoys.length = 0;
        // 6 Boyas distribuidas verticalmente
        const totalBuoys = 6;
        const marginY = height * 0.15;
        const availHeight = height - (marginY * 2);
        
        for(let i=0; i<totalBuoys; i++) {
            // Zigzag en X
            // Las pares m치s cerca de la costa, impares m치s mar adentro
            let xOffset = (i % 2 === 0) ? width * 0.6 : width * 0.4;
            
            let bY = marginY + (availHeight / (totalBuoys - 1)) * i;
            // A침adir un poco de "ruido" para que no sea perfecto artificial
            let bX = xOffset + (Math.random() - 0.5) * 20; 

            buoys.push({
                id: `B-0${i+1}`,
                x: bX,
                y: bY,
                range: 150, // Rango de detecci칩n visual en pixeles
                active: false
            });
        }
    }

    // ==========================================
    // 3. IA PREDICTIVA (MARKOV + PAPER)
    // ==========================================
    class PredictiveEngine {
        constructor() {
            this.particles = [];
            this.maxParticles = 80;
            this.zNumber = 0.85; 
        }

        spawnParticle(x, y) {
            this.particles.push({
                x: x + (Math.random() - 0.5) * 40,
                y: y + (Math.random() - 0.5) * 40,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 1.0
            });
        }

        update(targetX, targetY) {
            if (this.particles.length < this.maxParticles) this.spawnParticle(targetX, targetY);

            this.particles.forEach((p, index) => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Atracci칩n Markoviana (Colapso hacia la verdad)
                let dx = targetX - p.x;
                let dy = targetY - p.y;
                p.vx += dx * 0.02 * this.zNumber;
                p.vy += dy * 0.02 * this.zNumber;
                
                p.vx *= 0.92; p.vy *= 0.92; // Fricci칩n del medio
                p.life -= 0.01;
                if (p.life <= 0) this.particles.splice(index, 1);
            });
        }

        draw(ctx) {
            ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
            this.particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }

    // ==========================================
    // 4. SUBMARINO
    // ==========================================
    const subTarget = {
        x: width * 0.2, // Empieza mar adentro
        y: height * 0.1,
        speed: 0.8,
        angle: Math.PI / 4, // Rumbo SE
        turnRate: 0.02
    };

    const tridenteAI = new PredictiveEngine();

    // ==========================================
    // ANIMACI칍N PRINCIPAL
    // ==========================================
    resize(); // Init inicial

    function animate() {
        // A. Fondo (Mar profundo) - No borramos todo para dejar estelas leves
        ctx.fillStyle = "rgba(0, 9, 16, 0.2)"; 
        ctx.fillRect(0, 0, width, height);

        // B. Dibujar Mapa (Tierra) - Debe tapar las estelas
        ctx.beginPath();
        ctx.moveTo(width, 0); // Esquina sup der
        ctx.lineTo(width, height); // Esquina inf der
        // Dibujar borde costero
        for(let i=coastPoints.length-1; i>=0; i--) {
            ctx.lineTo(coastPoints[i].x, coastPoints[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = "#0a1510"; // Color Tierra Oscura
        ctx.fill();
        ctx.strokeStyle = "#004433"; // Borde costero
        ctx.lineWidth = 2;
        ctx.stroke();

        // Etiquetas Geogr치ficas
        ctx.fillStyle = "#006655";
        ctx.font = "12px Monospace";
        ctx.fillText("LOS VILOS", width - 80, 30);
        ctx.fillText("SAN ANTONIO", width - 100, height - 30);

        // C. L칩gica del Submarino
        subTarget.x += Math.cos(subTarget.angle) * subTarget.speed;
        subTarget.y += Math.sin(subTarget.angle) * subTarget.speed;

        // --- COLISIONES ---
        // 1. Rebote con la Costa (No puede tocar tierra)
        let coastX = getCoastX(subTarget.y);
        if (subTarget.x > coastX - 15) { // 15px de margen de seguridad
            subTarget.angle = Math.PI - subTarget.angle + 0.2; // Rebote hacia el mar
            subTarget.x = coastX - 20; // Empujar afuera
        }
        // 2. Rebote bordes pantalla
        if (subTarget.x < 0) subTarget.angle = Math.PI - subTarget.angle;
        if (subTarget.y < 0 || subTarget.y > height) subTarget.angle = -subTarget.angle;
        
        // Movimiento aleatorio suave
        subTarget.angle += (Math.random() - 0.5) * 0.05;

        // D. Dibujar Boyas y Detecci칩n
        let detected = false;
        buoys.forEach(buoy => {
            // Dibujar Boya
            ctx.fillStyle = "#ffff00";
            ctx.beginPath();
            ctx.arc(buoy.x, buoy.y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Texto ID
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.fillText(buoy.id, buoy.x + 8, buoy.y - 8);

            // Anillos de rango pasivos
            ctx.strokeStyle = "rgba(255, 255, 0, 0.1)";
            ctx.beginPath();
            ctx.arc(buoy.x, buoy.y, buoy.range, 0, Math.PI * 2);
            ctx.stroke();

            // DETECCI칍N: Calcular distancia al sub
            let dist = Math.hypot(subTarget.x - buoy.x, subTarget.y - buoy.y);
            if (dist < buoy.range) {
                detected = true;
                // L칤nea de contacto
                ctx.strokeStyle = "red";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(buoy.x, buoy.y);
                ctx.lineTo(subTarget.x, subTarget.y);
                ctx.stroke();
                
                // C칤rculo de alerta
                ctx.strokeStyle = "red";
                ctx.beginPath();
                ctx.arc(buoy.x, buoy.y, dist, 0, Math.PI*2);
                ctx.stroke();
            }
        });

        // Actualizar HUD
        const statusText = document.getElementById('target-status');
        if(detected) {
            statusText.innerText = "DETECTADO (FIRMA S42)";
            statusText.style.color = "red";
        } else {
            statusText.innerText = "MONITOREANDO RUIDO AMBIENTE...";
            statusText.style.color = "#00ffcc";
        }

        // E. Dibujar IA Predictiva (Nube Azul)
        // Solo mostramos la predicci칩n si hay alguna detecci칩n (o simulaci칩n constante)
        tridenteAI.update(subTarget.x, subTarget.y);
        tridenteAI.draw(ctx);

        // F. Submarino "Real" (Simulado visualmente tenue)
        ctx.fillStyle = "rgba(255, 50, 50, 0.6)";
        ctx.beginPath();
        ctx.moveTo(subTarget.x, subTarget.y);
        // Dibujarlo como un peque침o tri치ngulo rotado
        ctx.lineTo(subTarget.x - 10 * Math.cos(subTarget.angle - 0.5), subTarget.y - 10 * Math.sin(subTarget.angle - 0.5));
        ctx.lineTo(subTarget.x - 10 * Math.cos(subTarget.angle + 0.5), subTarget.y - 10 * Math.sin(subTarget.angle + 0.5));
        ctx.fill();

        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>
