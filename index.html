<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SISTEMA TRIDENTE 游댬 | C4I TACTICAL DISPLAY</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000508; /* Negro profundo oce치nico */
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }

        #sonar-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle, #001a25 0%, #000000 90%);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI OVERLAY - HUD T츼CTICO */
        .hud-panel {
            position: absolute;
            padding: 15px;
            border: 1px solid #005544;
            background: rgba(0, 10, 10, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
            pointer-events: none; /* Dejar pasar clicks al canvas */
        }

        #top-left {
            top: 20px;
            left: 20px;
        }

        #bottom-right {
            bottom: 20px;
            right: 20px;
            text-align: right;
        }

        h1 { margin: 0; font-size: 24px; text-shadow: 0 0 5px #00ffcc; }
        h2 { margin: 0; font-size: 14px; color: #008866; margin-bottom: 5px; }
        p { margin: 2px 0; font-size: 12px; }
        
        .alert { color: #ff3333; font-weight: bold; animation: blink 1s infinite; }
        .math-metric { color: #ffff00; }

        @keyframes blink { 50% { opacity: 0; } }
        
        /* Efecto CRT (Monitor Viejo) */
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 204, 0.04) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }
        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }
    </style>
</head>
<body>

    <div id="sonar-container">
        <canvas id="tridenteCanvas"></canvas>
        <div class="scanline"></div>

        <div id="top-left" class="hud-panel">
            <h1>SISTEMA TRIDENTE 游댬</h1>
            <h2>AN츼LISIS ESPECTRAL & PREDICTIVO</h2>
            <p>ESTADO: <span class="alert">SEGUIMIENTO ACTIVO</span></p>
            <p>OBJETIVO: CLASE SCORP칃NE (S42)</p>
            <hr style="border-color: #004433">
            <p>M칍DULO MARKOV: <span style="color:#0f0">ACTIVADO</span></p>
            <p>ECUACI칍N MAESTRA (KOLMOGOROV): <span style="color:#0f0">CONVERGIENDO</span></p>
        </div>

        <div id="bottom-right" class="hud-panel">
            <h2>M칄TRICAS DEL MEDIO ($Z_I$)</h2>
            <p>CONSTANTE $C_{s8}$: SATURADA (8-bit)</p>
            <p>VISCOSIDAD EFECTIVA: <span class="math-metric" id="viscosity-val">0.00</span> Pa췅s</p>
            <p>ENTROP칈A ($S$): <span class="math-metric" id="entropy-val">BAJA</span></p>
            <p>PROBABILIDAD ($P(X|Y)$): 98.4%</p>
        </div>
    </div>

<script>
    const canvas = document.getElementById('tridenteCanvas');
    const ctx = canvas.getContext('2d');

    // Ajuste de tama침o
    let width, height;
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // CLASE 1: EL MOTOR F칈SICO (SUBMARINO)
    // ==========================================
    const subTarget = {
        x: width / 2,
        y: height / 2,
        speed: 0.5,
        angle: Math.random() * Math.PI * 2,
        turnRate: 0.005
    };

    // ==========================================
    // CLASE 2: MOTOR PREDICTIVO (MARKOV + TU PAPER)
    // ==========================================
    class PredictiveEngine {
        constructor() {
            this.particles = []; // "Niebla" de probabilidad
            this.maxParticles = 100;
            this.zNumber = 0.85; // Tu m칠trica Z (0 a 1)
        }

        // Generar part칤culas basadas en la incertidumbre inicial
        spawnParticle(x, y) {
            this.particles.push({
                x: x + (Math.random() - 0.5) * 50, // Incertidumbre espacial
                y: y + (Math.random() - 0.5) * 50,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 1.0
            });
        }

        update(targetX, targetY) {
            // L칩gica MCMC (Monte Carlo): Las part칤culas intentan adivinar el futuro
            // Si el Z-Number es alto (tu paper), el caos se reduce.
            
            // Generar nuevas si faltan
            if (this.particles.length < this.maxParticles) {
                this.spawnParticle(targetX, targetY);
            }

            this.particles.forEach((p, index) => {
                // Ecuaci칩n de movimiento de la part칤cula
                p.x += p.vx;
                p.y += p.vy;
                
                // ATRACCI칍N MARKOVIANA:
                // Las part칤culas son "haladas" hacia la soluci칩n m치s probable
                // simulando el colapso de la funci칩n de onda al recibir datos.
                let dx = targetX - p.x;
                let dy = targetY - p.y;
                
                // Aplicamos tu filtro Z_I aqu칤:
                // Cuanto mayor es Z, m치s fuerte es la correcci칩n hacia la verdad f칤sica
                p.vx += dx * 0.01 * this.zNumber;
                p.vy += dy * 0.01 * this.zNumber;
                
                // Fricci칩n (simulando el medio viscoso)
                p.vx *= 0.95; 
                p.vy *= 0.95;

                p.life -= 0.005;
                
                // Eliminar part칤culas muertas
                if (p.life <= 0) this.particles.splice(index, 1);
            });
        }

        draw(ctx) {
            // Dibujar la "Nube de Probabilidad"
            ctx.fillStyle = "rgba(0, 255, 255, 0.4)";
            this.particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI * 2); // El tama침o se reduce con la vida
                ctx.fill();
            });

            // Dibujar VECTOR PREDICTIVO (Flecha verde)
            // Esto muestra hacia d칩nde cree Kolmogorov que va el submarino
            let avgX = this.particles.reduce((sum, p) => sum + p.x, 0) / this.particles.length;
            let avgY = this.particles.reduce((sum, p) => sum + p.y, 0) / this.particles.length;

            ctx.strokeStyle = "#00FF00";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(avgX, avgY);
            // Proyecci칩n a futuro (simulada)
            ctx.lineTo(avgX + (subTarget.x - avgX)*3, avgY + (subTarget.y - avgY)*3);
            ctx.stroke();
            
            ctx.fillStyle = "#00FF00";
            ctx.fillText("ESTIMACI칍N MARKOVIANA", avgX + 10, avgY);
        }
    }

    const tridenteAI = new PredictiveEngine();

    // ==========================================
    // CLASE 3: GRID T츼CTICO (BATTLESHIP)
    // ==========================================
    function drawGrid() {
        ctx.strokeStyle = "rgba(0, 85, 68, 0.3)"; // Verde oscuro tenue
        ctx.lineWidth = 1;
        ctx.fillStyle = "rgba(0, 255, 204, 0.5)"; // Texto Cyan
        ctx.font = "10px Monospace";

        const gridSize = 100; // Tama침o de cada celda
        
        // Coordenadas ficticias de inicio (Cerca de Valpara칤so por ejemplo)
        let startLat = -33.0;
        let startLon = -71.6;

        // L칤neas Verticales (Meridianos)
        for (let x = 0; x < width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
            
            // Texto de Longitud
            let lon = startLon + (x / 1000);
            ctx.fillText(`LON ${lon.toFixed(3)}춿W`, x + 5, 15);
        }

        // L칤neas Horizontales (Paralelos)
        for (let y = 0; y < height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();

            // Texto de Latitud
            let lat = startLat - (y / 1000);
            ctx.fillText(`LAT ${lat.toFixed(3)}춿S`, 5, y - 5);
        }
    }

    // ==========================================
    // RENDER LOOP PRINCIPAL
    // ==========================================
    let sonarAngle = 0;

    function animate() {
        // 1. Limpiar pantalla con un rastro (efecto fade)
        ctx.fillStyle = "rgba(0, 5, 8, 0.1)"; // Deja estela
        ctx.fillRect(0, 0, width, height);

        // 2. Dibujar Grid T치ctico
        drawGrid();

        // 3. Actualizar F칤sica del Submarino (Simulaci칩n)
        subTarget.x += Math.cos(subTarget.angle) * subTarget.speed;
        subTarget.y += Math.sin(subTarget.angle) * subTarget.speed;
        
        // Cambio de rumbo suave
        subTarget.angle += (Math.random() - 0.5) * 0.05;

        // Rebote en bordes
        if (subTarget.x < 0 || subTarget.x > width) subTarget.angle = Math.PI - subTarget.angle;
        if (subTarget.y < 0 || subTarget.y > height) subTarget.angle = -subTarget.angle;

        // 4. Actualizar IA (Tridente Upgrade)
        tridenteAI.update(subTarget.x, subTarget.y);
        tridenteAI.draw(ctx);

        // 5. Dibujar el Submarino Real (El punto rojo oculto)
        // En la vida real esto no se ve, pero para la demo lo mostramos tenue
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(subTarget.x, subTarget.y, 4, 0, Math.PI * 2);
        ctx.fill();

        // 6. Dibujar el Barrido del Sonar (Radar Sweep)
        sonarAngle += 0.02;
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(sonarAngle);
        
        // Haz del sonar
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, "rgba(0, 255, 204, 0.5)");
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, width, -0.1, 0.1); // Cono
        ctx.fill();
        ctx.restore();

        // 7. Actualizar datos aleatorios del HUD (Simulaci칩n)
        if (Math.random() > 0.95) {
            document.getElementById('viscosity-val').innerText = (Math.random() * 0.005).toFixed(4);
        }

        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>
